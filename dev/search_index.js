var documenterSearchIndex = {"docs":
[{"location":"setup/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"setup/#Oolong","page":"Setup","title":"Oolong","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"In Julia-REPL, enter package-mode by typing \"]\". Then write:","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"add https://github.com/oolongtensors/oolong","category":"page"},{"location":"setup/#Compilation","page":"Setup","title":"Compilation","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"To compile Oolong to GEM, one needs to first install Firedrake. Then they should activate the Firedrake virtual environment and run the following commands (source):","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"(firedrake) > julia\njulia> ENV[\"PYTHON\"] = Sys.which(\"python\")\njulia> using Pkg\njulia> Pkg.build(\"PyCall\")","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"These commands make the PyCall-Python point to Firedrake's Python.","category":"page"},{"location":"tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"The tensor product of two vector spaces E and F is a new vector space, denoted by EF. It is spanned by the elements ef where e in E= e_i phi_i and  f in F= f_j psi_j then g in E  F= g_ij phi_i  psi_j.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Tensors are these objects in the vector spaces created by tensors products","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Mathematically, tensor T is T in E_1E_pF_1^F_q^ (or a permutation of these), where E_i and F_j^ are vector and dual spaces, respectively Programmatically this means that tensors objects with shape and data. Shape describes the tensor space E_1E_pF_1^F_q^ and data describes the vector within this tensor space.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"There are two main types of tensors in Oolong: tensors created from multidimensional arrays:","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"A = Tensor([1 2 ; 3 4], R2, R2)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"and tensors with unknown value","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"B = VariableTensor(R2, R2)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Zero and and identity tensors have their own types.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Z = ZeroTensor(V4)\nI = DeltaTensor(V4, R2)","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"There is also a type for tensors where all entries have the same value.","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"julia> C = ConstantTensor(3, V4, V, V4')\nConstantTensor{Int64,3}, 3, shape: V4_2⊗ V_3⊗ V4_2*","category":"page"},{"location":"tensors/","page":"Tensors","title":"Tensors","text":"Modules = [TensorDSL]\nPages   = [\"Tensors.jl\"]","category":"page"},{"location":"tensors/#TensorDSL.Scalar","page":"Tensors","title":"TensorDSL.Scalar","text":"A union type for everything that can be treated as a scalar. Includes tensors of rank 0 and numbers.\n\n\n\n\n\n","category":"constant"},{"location":"tensors/#TensorDSL.AbstractTensor","page":"Tensors","title":"TensorDSL.AbstractTensor","text":"AbstractTensor{rank} <: Node\n\nA type for all the tensors and tensor like objects.\n\nThe rank means the number of vector spaces in the shape. For example AbstractTensor{0} is a scalar, and AbstractTensor{2} a matrix.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.ConstantTensor","page":"Tensors","title":"TensorDSL.ConstantTensor","text":"ConstantTensor(value::T, Vs::Vararg{AbstractVectorSpace}) where (T <: Scalar)\n\nA tensor where every entry is of the same value. Creates ConstantTensor{T, length(Vs)}. If value == 0, creates a ZeroTensor.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.DeltaTensor","page":"Tensors","title":"TensorDSL.DeltaTensor","text":"DeltaTensor(Vs::Vararg{AbstractVectorSpace})\n\nSymbolic delta tensor. Each vector space in Vs must be either equal to other vector spaces or their duals.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.Tensor","page":"Tensors","title":"TensorDSL.Tensor","text":"Tensor(x::Array{T}, Vs::Vararg{AbstractVectorSpace}) where T\n\nTensor{T, length(VS)} created from a multidimensional array.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.Tensor-Union{Tuple{T}, Tuple{T}} where T<:Union{Number, AbstractTensor{0}}","page":"Tensors","title":"TensorDSL.Tensor","text":"Tensor(x::T) where (T <: Scalar)\n\nTurns a non-tensor scalar into a tensor. A tensor scalar does not change.\n\n\n\n\n\n","category":"method"},{"location":"tensors/#TensorDSL.TerminalTensor","page":"Tensors","title":"TensorDSL.TerminalTensor","text":"TerminalTensor{rank} <: AbstractTensor{rank}\n\nA type for the tensors which are terminal nodes, i.e not created by operations.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.VariableTensor","page":"Tensors","title":"TensorDSL.VariableTensor","text":"VariableTensor(name::String, shape::Vararg{AbstractVectorSpace})\n\nTensors of which we only know in which vector spaces their indices are. The rank is the lenght of the shape.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#TensorDSL.ZeroTensor","page":"Tensors","title":"TensorDSL.ZeroTensor","text":"ZeroTensor(Vs::Vararg{AbstractVectorSpace})\n\nSymbolic zero tensor of the shape Vs.\n\n\n\n\n\n","category":"type"},{"location":"vectorspaces/#Vector-Spaces","page":"Vector Spaces","title":"Vector Spaces","text":"","category":"section"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"The shape of Tensors is a represented as a tuple of vector spaces. ","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Vector spaces with or without a known number of dimensions. (Note: vector spaces with unknow dimension cannot be compiled to GEM.)","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"V4 = VectorSpace(4)\nV = VectorSpace()","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Dual spaces","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"julia> typeof(V4')\nDualVectorSpace","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Real vector spaces","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"R2 = RnSpace(2)","category":"page"},{"location":"vectorspaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Modules = [TensorDSL]\nPages   = [\"VectorSpace.jl\"]","category":"page"},{"location":"vectorspaces/#TensorDSL.AbstractVectorSpace","page":"Vector Spaces","title":"TensorDSL.AbstractVectorSpace","text":"Abstract vector space type.\n\n\n\n\n\n","category":"type"},{"location":"vectorspaces/#TensorDSL.DualVectorSpace","page":"Vector Spaces","title":"TensorDSL.DualVectorSpace","text":"DualVectorSpace(vectorspace::AbstractVectorSpace)\n\nDual of a given vector space.\n\n\n\n\n\n","category":"type"},{"location":"vectorspaces/#TensorDSL.RnSpace","page":"Vector Spaces","title":"TensorDSL.RnSpace","text":"RnSpace(dim::Int)\n\nVector space corresponding to R^n for some n.\n\n\n\n\n\n","category":"type"},{"location":"vectorspaces/#TensorDSL.VectorSpace","page":"Vector Spaces","title":"TensorDSL.VectorSpace","text":"VectorSpace(dim::Union{Int, Nothing})\n\nA vector space with optional dimension. Attribute id distinguishes between different vector spaces of the same dimension. User should not need to set id.\n\n\n\n\n\n","category":"type"},{"location":"vectorspaces/#Base.adjoint-Tuple{AbstractVectorSpace}","page":"Vector Spaces","title":"Base.adjoint","text":"Base.adjoint(V::AbstractVectorSpace)\n\nReturns the dual(V).\n\n\n\n\n\n","category":"method"},{"location":"vectorspaces/#TensorDSL.dim-Tuple{VectorSpace}","page":"Vector Spaces","title":"TensorDSL.dim","text":"dim(V::AbstractVectorSpace)\n\nReturns the dimension V.\n\n\n\n\n\n","category":"method"},{"location":"vectorspaces/#TensorDSL.dual-Tuple{VectorSpace}","page":"Vector Spaces","title":"TensorDSL.dual","text":"dual(V::AbstractVectorSpace)\n\nReturns the dual of V.\n\n\n\n\n\n","category":"method"},{"location":"future/#Improvements","page":"Improvements","title":"Improvements","text":"","category":"section"},{"location":"future/#Optimisation","page":"Improvements","title":"Optimisation","text":"","category":"section"},{"location":"future/","page":"Improvements","title":"Improvements","text":"The performance of Oolong has not been tested with real-world examples. Hence it has also not been optimised.","category":"page"},{"location":"future/#Features","page":"Improvements","title":"Features","text":"","category":"section"},{"location":"future/","page":"Improvements","title":"Improvements","text":"Multiple features could be added to the language. These are documented in the issues.","category":"page"},{"location":"future/#Compilation-in-Julia","page":"Improvements","title":"Compilation in Julia","text":"","category":"section"},{"location":"future/","page":"Improvements","title":"Improvements","text":"Whether compilation could be done in Julia, and how well that would work, is still an open question.","category":"page"},{"location":"ast/#AST","page":"Abstract syntax tree","title":"AST","text":"","category":"section"},{"location":"ast/","page":"Abstract syntax tree","title":"Abstract syntax tree","text":"Oolong generates an abstract syntax tree of tensor operations. Each operation on tensors is translated to an operation node.","category":"page"},{"location":"ast/","page":"Abstract syntax tree","title":"Abstract syntax tree","text":"using TensorDSL\nA = VariableTensor(\"A\")\nB = VariableTensor(\"B\")\nA + 3*B\n\n# output\n\nAddOperation{0}\n    VariableTensor{0}, A, shape: ()\n    OuterProductOperation{0}\n        ConstantTensor{Int64,0}, 3, shape: ()\n        VariableTensor{0}, B, shape: ()","category":"page"},{"location":"ast/","page":"Abstract syntax tree","title":"Abstract syntax tree","text":"This tree can then be traversed using traversal-function. Examples of this include togem(node::Node) and differentiate(A::AbstractTensor{0}, x::VariableTensor{0}).","category":"page"},{"location":"ast/","page":"Abstract syntax tree","title":"Abstract syntax tree","text":"The function assign(node::Node, pair::Pair{VariableTensor{rank}, T}) where {rank, T<:AbstractTensor{rank}} can be used to assign values for the variables in the tree.","category":"page"},{"location":"ast/","page":"Abstract syntax tree","title":"Abstract syntax tree","text":"Modules = [TensorDSL]\nPages   = [\"Node.jl\", \"Traversal.jl\", \"Assignment.jl\"]","category":"page"},{"location":"ast/#TensorDSL.Node","page":"Abstract syntax tree","title":"TensorDSL.Node","text":"Node\n\nAbstract type for nodes in the AST tree.\n\n\n\n\n\n","category":"type"},{"location":"ast/#TensorDSL.traversal-Tuple{Any,Function,Function,Any,Any,Union{Nothing, Dict},Bool}","page":"Abstract syntax tree","title":"TensorDSL.traversal","text":"traversal(node, pretraversalfn::Function, visitfn::Function,\n    pretraversalfnargs::Union{Any, Nothing}, visitfnargs::Union{Any, Nothing},\n    visited::Union{Dict, Nothing}, posttraversal=false)\n\nTraverses an AST, calling visitfn on the nodes of the tree.\n\nArguments\n\nnode: the root of the tree to traverse. Assumes that each node has children\n\nattribute.\n\npretraversalfn::Function A function to be executed before the traversal\nvisitfn::Function The function that is executed on each visit. If\n\nposttraversal is false, and visitfnargs nothing, the function must have signature  visitfn(visited, node, new_children...). If visitfnargs is not nothing, the signature is visitfn(visited, node, visitfnargs, new_children...). If posttraversal is true, the signature must bevisitfn(node, fn), orvisitfn(node, visitfn, fn), wherefn` is a function that calls traversal on a node.\n\npretraversalfnargs::Union{Any, Nothing} Arguments for the pretraversalfn.\nvisitfnargs::Union{Any, Nothing} Arguments for traversalfn.\nvisited::Union{Dict, Nothing} If not nothing, a dictionary with the results\n\nof calling traversalfn on different nothing. If nothing, this dictionary is created in traversal.\n\nposttraversal=false Determines the way traversal traverses each node. If\n\nposttraversal=false, the traversal first processes the children of a node, and then the parent node (example: togem(node::Node)). If posttraversal=true, the visitfn first processes the parent and then calls visitfn on its children if needed (example: differentiate(A::AbstractTensor{0}, x::VariableTensor{0})).\n\n\n\n\n\n","category":"method"},{"location":"ast/#TensorDSL.assign-Union{Tuple{T}, Tuple{rank}, Tuple{Node,Pair{VariableTensor{rank},T}}} where T<:AbstractTensor{rank} where rank","page":"Abstract syntax tree","title":"TensorDSL.assign","text":"assign(node::Node, pair::Pair{VariableTensor{rank}, T}) where {rank, T<:AbstractTensor{rank}}\nassign(node::Node, pair::Pair{T, N}) where {T<:AbstractTensor{0}, N<:Number}\nassign(node::Node, pair::Pair{T1, T2}) where {T1<:AbstractVectorSpace, T2<:AbstractVectorSpace}\nassign(node::Node, pair::Pair{FreeIndex{T}, Union{Int, FixedIndex{T}}}) where {T<:AbstractVectorSpace}\n\nCreate a new node from node, where every value first(pair) is replaced with last(pair). Can be used on tensors, indices and vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"indices/#Indices","page":"Indices","title":"Indices","text":"","category":"section"},{"location":"indices/","page":"Indices","title":"Indices","text":"Indices in Oolong are tied to particular AbstractVectorSpace. When creating an index, one must also specify the vector space they are indexing.","category":"page"},{"location":"indices/","page":"Indices","title":"Indices","text":"Indices on their own are not nodes in AST. Instead, a tuple of indices can be stored in an Indices-node. In most cases the user does not need to create this, as the index-operations create their own Indices-objects.","category":"page"},{"location":"indices/","page":"Indices","title":"Indices","text":"Modules = [TensorDSL]\nPages   = [\"Indices.jl\"]","category":"page"},{"location":"indices/#TensorDSL.FixedIndex","page":"Indices","title":"TensorDSL.FixedIndex","text":"FixedIndex(V::T, value::Int) where {T<:AbstractVectorSpace}\n\nAn index whose value is known.\n\n\n\n\n\n","category":"type"},{"location":"indices/#TensorDSL.FreeIndex","page":"Indices","title":"TensorDSL.FreeIndex","text":"FreeIndex(V::T, name::String, id=0) where {T<:AbstractVectorSpace}\n\nAn index whose value is not known. Identified by its name. There should be no need to set the id by the user.\n\n\n\n\n\n","category":"type"},{"location":"indices/#TensorDSL.Index","page":"Indices","title":"TensorDSL.Index","text":"Index\n\nAbstract index supertype.\n\n\n\n\n\n","category":"type"},{"location":"indices/#TensorDSL.Indices","page":"Indices","title":"TensorDSL.Indices","text":"Indices(indices::Vararg{Index})\n\nA node that represents a tuple of indices.\n\n\n\n\n\n","category":"type"},{"location":"indices/#Base.adjoint-Tuple{FreeIndex}","page":"Indices","title":"Base.adjoint","text":"Base.adjoint(i::Index)\n\nCreates an index with the same name/value in the dual space.\n\n\n\n\n\n","category":"method"},{"location":"indices/#TensorDSL.toindex-Tuple{AbstractVectorSpace,Int64}","page":"Indices","title":"TensorDSL.toindex","text":"toindex(V::AbstractVectorSpace, i::Union{String, Int, Index})\n\nGiven a vectorspace V, creates an index of the string or integer i. If i is an index, returns i.\n\n\n\n\n\n","category":"method"},{"location":"python/#Python-Julia-Compatibility","page":"Python-Julia compatibility","title":"Python-Julia Compatibility","text":"","category":"section"},{"location":"python/#Arrays","page":"Python-Julia compatibility","title":"Arrays","text":"","category":"section"},{"location":"python/","page":"Python-Julia compatibility","title":"Python-Julia compatibility","text":"Python arrays are indexed from 0, whereas Julia-arrays are indexed from 1. This tends to be easy to get around by adding/substracting 1 to indices, but needs to be remembered.","category":"page"},{"location":"python/","page":"Python-Julia compatibility","title":"Python-Julia compatibility","text":"Julia arrays are column-major, whereas Python-arrays are row-major. This might affect performance.","category":"page"},{"location":"python/#Objects","page":"Python-Julia compatibility","title":"Objects","text":"","category":"section"},{"location":"python/","page":"Python-Julia compatibility","title":"Python-Julia compatibility","text":"PyCall tends to convert Python objects to Julia, which sometimes loses information. For example Python's namedtuple is converted to tuple in Julia. There are two ways around this: first one can just avoid Python-Julia conversions - which is what Oolong does. Secondly, pycall-function can be used to return Python-objects.","category":"page"},{"location":"python/#Initialisation","page":"Python-Julia compatibility","title":"Initialisation","text":"","category":"section"},{"location":"python/","page":"Python-Julia compatibility","title":"Python-Julia compatibility","text":"Calling PyCall from modules is not quite as straightforward as one might think. The link provides a good quide.","category":"page"},{"location":"#Oolong","page":"Home","title":"Oolong","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Oolong is prototype of a symbolic Tensor DSL in Julia. Its goal is to see how well Julia works for creating a DSL and how well it could work together with  Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorDSL\nA = Tensor([1 2 ; 3 4], RnSpace(2), RnSpace(2))\nB = VariableTensor(\"B\", RnSpace(2), RnSpace(2))\nx = FreeIndex(RnSpace(2), \"x\")\n\n(A + B)[1, x]\n\n# output\n\nIndexingOperation{0}\n    AddOperation{2}\n        Tensor{Int64,2}, [1 2; 3 4], shape: R^2⊗ R^2\n        VariableTensor{2}, B, shape: R^2⊗ R^2\n    (1, x)","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/#Tensor-operations","page":"Operations","title":"Tensor operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Most basic tensor operations are represented in Oolong.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Tensors of the same shape can be added together.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using TensorDSL\nR2 = RnSpace(2)\nA = Tensor([1 2; 3 4], R2, R2)\nB = VariableTensor(\"B\", R2, R2)\nA + B\n# output\nAddOperation{2}\n    Tensor{Int64,2}, [1 2; 3 4], shape: R^2⊗ R^2\n    VariableTensor{2}, B, shape: R^2⊗ R^2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Outer product","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using TensorDSL\nR2 = RnSpace(2)\nA = Tensor([1 2; 3 4], R2, R2)\nC = ZeroTensor(R2)\nA ⊗ C\n\n# output\nOuterProductOperation{3}\n    Tensor{Int64,2}, [1 2; 3 4], shape: R^2⊗ R^2\n    ZeroTensor{1}, shape: R^2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Tensors can be indexed using both FreeIndex objects and integers.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using TensorDSL\nV = VectorSpace()\nx = FreeIndex(V, \"x\")\nA = VariableTensor(\"A\", VectorSpace(3), V)\nA[1, x]\n# output\nIndexingOperation{0}\n    VariableTensor{2}, A, shape: V3_2⊗ V_1\n    (1, x)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Component tensor is an operation where a free index of a tensor expression is \"rolled out\". This turn a free index into a shape in the tensor expression.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using TensorDSL\nV = VectorSpace()\nx = FreeIndex(V, \"x\")\nA = VariableTensor(\"A\", V', VectorSpace(3))\ncomponenttensor(A[x', 1], x')\n# output\nComponentTensorOperation{1}\n    IndexingOperation{0}\n        VariableTensor{2}, A, shape: V_3*⊗ V3_4\n        (x*, 1)\n    (x*,)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Tensor contraction is invoked whenever the expression is indexed with an upper and lower index.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using TensorDSL\nV = VectorSpace()\nx = FreeIndex(V, \"x\")\nA = VariableTensor(\"A\", V)\nB = VariableTensor(\"B\", V')\nA[x] ⊗ B[x']\n# output\nIndexSumOperation{0}\n    OuterProductOperation{0}\n        IndexingOperation{0}\n            VariableTensor{1}, A, shape: V_5\n            (x,)\n        IndexingOperation{0}\n            VariableTensor{1}, B, shape: V_5*\n            (x*,)\n    (x,)","category":"page"},{"location":"operations/#Functions","page":"Operations","title":"Functions","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Modules = [TensorDSL]\nPages   = [\"Operations.jl\"]\nOrder   = [:function]","category":"page"},{"location":"operations/#Base.:*-Tuple{Union{Number, AbstractTensor{0}},AbstractTensor}","page":"Operations","title":"Base.:*","text":"Base.:*(x::Scalar, A::AbstractTensor)\n\nShorthand for multiplying a tensor by a scalar.  If multiplying a number by a variable, the number must be first.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:+-Tuple{Vararg{Node,N} where N}","page":"Operations","title":"Base.:+","text":"Base.:+(nodes::Vararg{Node})\n\nCreates an AddOperation whose children are the nodes. The shapes of the nodes must match.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:--Tuple{AbstractTensor}","page":"Operations","title":"Base.:-","text":"Base.:-(A::AbstractTensor)\n\nUnary minus. Creates an OuterProductOperation between ConstantTensor(-1) and A.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:--Union{Tuple{rank}, Tuple{AbstractTensor{rank},AbstractTensor{rank}}} where rank","page":"Operations","title":"Base.:-","text":"Base.:-(A::AbstractTensor{rank}, B::AbstractTensor{rank}) where rank\n\nBinary minus. Creates an AddOperation of A and -1*B.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:/-Tuple{AbstractTensor,AbstractTensor{0}}","page":"Operations","title":"Base.:/","text":"Base.:/(A::AbstractTensor, y::AbstractTensor{0})\n\nCreates a DivisionOperation where A is divived by y. y must be scalar-shaped.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:/-Tuple{AbstractTensor,Number}","page":"Operations","title":"Base.:/","text":"Base.:/(A::AbstractTensor, y::Number)\n\nCreates a DivisionOperation where A is divived by y.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:/-Tuple{Number,AbstractTensor{0}}","page":"Operations","title":"Base.:/","text":"Base.:/(y::Number, A::AbstractTensor{0})\n\nCreates a DivisionOperation where y is divided by A, where A must be a scalar.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:^-Tuple{AbstractTensor{0},AbstractTensor{0}}","page":"Operations","title":"Base.:^","text":"Base.:^(x::AbstractTensor{0}, y::AbstractTensor{0})\n\nRaises the scalar-shaped tensor x to the scalar-shaped power y. Returns a PowerOperation.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.:^-Tuple{AbstractTensor{0},Number}","page":"Operations","title":"Base.:^","text":"Base.:^(x::AbstractTensor{0}, y::Number)\n\nRaises the scalar-shaped tensor x to the power y. Returns a PowerOperation.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.getindex-Tuple{AbstractTensor,Vararg{Index,N} where N}","page":"Operations","title":"Base.getindex","text":"Base.getindex(A::AbstractTensor, ys::Vararg{Index})\n\nCreates an IndexingOperation of A indexed by ys. If every dimension of A is not indexed, creates a ComponentTensorOperation over the unindexed dimensions.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.getindex-Tuple{AbstractTensor,Vararg{Union{Int64, String, Index},N} where N}","page":"Operations","title":"Base.getindex","text":"Base.getindex(A::AbstractTensor, ys::Vararg{Union{String, Int, Index}})\n\nA convenience function that allows indexing a tensor by an integer. The function creates a corresponding FixedIndex object in the appropiate vector space.\n\nTechnically the function can also create a FreeIndex from a string, but this is not recommended, because the syntax makes no distinction between upper and lower indices.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.sqrt-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.sqrt","text":"Base.sqrt(x::AbstractTensor{0})\n\nReturns the square root of x as a PowerOperation.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.transpose-Tuple{AbstractTensor}","page":"Operations","title":"Base.transpose","text":"Base.transpose(A::AbstractTensor)\n\nReverses the shape of A. Does this by indexing A and then creating a ComponentTensorOperation with the indices reversed.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.:⊗-Tuple{AbstractTensor,AbstractTensor}","page":"Operations","title":"TensorDSL.:⊗","text":"⊗(A::AbstractTensor, B::AbstractTensor)\n\nReturns an OuterProductOperation with A and B as its children.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.componenttensor-Tuple{AbstractTensor,Vararg{Index,N} where N}","page":"Operations","title":"TensorDSL.componenttensor","text":"componenttensor(A::AbstractTensor, indices::Vararg{Index})\n\nCreates a ComponentTensorOperation of A over indices. Indices must be a subset of the free indices of A.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.contractioncheck-Tuple{AbstractTensor}","page":"Operations","title":"TensorDSL.contractioncheck","text":"contractioncheck(A::AbstractTensor)\n\nChecks if we have have an upper and lower index. If there is, we create an IndexSumOperation node.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.trace-Tuple{AbstractTensor{2}}","page":"Operations","title":"TensorDSL.trace","text":"trace(A::AbstractTensor{2})\n\nReturns the trace of a matrix of the shape (V, V'). \n\n\n\n\n\n","category":"method"},{"location":"operations/#Trigonometry","page":"Operations","title":"Trigonometry","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Modules = [TensorDSL]\nPages   = [\"Trigonometry.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"operations/#Base.acos-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.acos","text":"Base.acos(s::AbstractTensor{0})\n\nReturns a ArccosineOperation represeting arccosine of s.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.asin-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.asin","text":"Base.asin(s::AbstractTensor{0})\n\nReturns a ArcsineOperation represeting arcsine of s.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.atan-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.atan","text":"Base.atan(s::AbstractTensor{0})\n\nReturns a ArctangentOperation represeting arctangent of s.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.cos-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.cos","text":"Base.cos(s::AbstractTensor{0})\n\nReturns a CosineOperation represeting cosine of s in radians.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.sin-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.sin","text":"Base.sin(s::AbstractTensor{0})\n\nReturns a SineOperation represeting sine of s in radians.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Base.tan-Tuple{AbstractTensor{0}}","page":"Operations","title":"Base.tan","text":"Base.tan(s::AbstractTensor{0})\n\nReturns a TangentOperation represeting tangent of s in radians.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.ArccosineOperation","page":"Operations","title":"TensorDSL.ArccosineOperation","text":"CosineOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing cos of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.ArcsineOperation","page":"Operations","title":"TensorDSL.ArcsineOperation","text":"ArcsineOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing arcsin of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.ArctangentOperation","page":"Operations","title":"TensorDSL.ArctangentOperation","text":"ArctangentOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing arctan of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.CosineOperation","page":"Operations","title":"TensorDSL.CosineOperation","text":"CosineOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing cos of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.SineOperation","page":"Operations","title":"TensorDSL.SineOperation","text":"SineOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing sin of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.TangentOperation","page":"Operations","title":"TensorDSL.TangentOperation","text":"TangentOperation(A::AbstractTensor{rank}) where rank\n\nRepresents computing tan of A.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Differentation","page":"Operations","title":"Differentation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Modules = [TensorDSL]\nPages   = [\"Differentation.jl\"]","category":"page"},{"location":"operations/#TensorDSL.differentiate-Tuple{AbstractTensor{0},VariableTensor{0}}","page":"Operations","title":"TensorDSL.differentiate","text":"differentiate(A::AbstractTensor{0}, x::VariableTensor{0})\n\nDifferentiates A w.r.t x.\n\n\n\n\n\n","category":"method"},{"location":"operations/#TensorDSL.divergence-Tuple{AbstractTensor{1},Vararg{VariableTensor{0},N} where N}","page":"Operations","title":"TensorDSL.divergence","text":"divergence(A::AbstractTensor{1}, vars::Vararg{VariableTensor{0}})\n\nComputes the divergence of a vector-shaped tensor A w.r.t vars.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Operation-nodes","page":"Operations","title":"Operation nodes","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Modules = [TensorDSL]\nPages   = [\"Operations.jl\"]\nOrder   = [:type]","category":"page"},{"location":"operations/#TensorDSL.AddOperation","page":"Operations","title":"TensorDSL.AddOperation","text":"AddOperation(children::Tuple{Vararg{AbstractTensor{rank}}},\n    freeindices::Tuple{Vararg{FreeIndex}}) where rank\n\nA node symbolising addition of tensors.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.ComponentTensorOperation","page":"Operations","title":"TensorDSL.ComponentTensorOperation","text":"ComponentTensorOperation(shape::Tuple{Vararg{AbstractVectorSpace}},\n    children::Tuple{AbstractTensor, Indices},\n    freeindices::Tuple{Vararg{FreeIndex}})\n\nA node symbolising component tensor.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.DivisionOperation","page":"Operations","title":"TensorDSL.DivisionOperation","text":"DivisionOperation(A::AbstractTensor, y::AbstractTensor{0})\n\nSymbolises dividing tensor A by a scalar-shaped tensor y.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.IndexSumOperation","page":"Operations","title":"TensorDSL.IndexSumOperation","text":"IndexSumOperation(A::AbstractTensor, indices::Indices, freeindices::Vararg{FreeIndex})\n\nSymbolises summing over given free index of a tensor.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.IndexingOperation","page":"Operations","title":"TensorDSL.IndexingOperation","text":"IndexingOperation(x::AbstractTensor, indices::Indices)\n\nA node symbolising indexing a tensor by its every dimension.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.Operation","page":"Operations","title":"TensorDSL.Operation","text":"Operation{rank} <: AbstractTensor{rank}\n\nA supertype for all tensor operations.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.OuterProductOperation","page":"Operations","title":"TensorDSL.OuterProductOperation","text":"OuterProductOperation(shape::Tuple{Vararg{AbstractVectorSpace}},\n    children::Tuple{AbstractTensor, AbstractTensor},\n\nA node symbolising tensor outer product.\n\n\n\n\n\n","category":"type"},{"location":"operations/#TensorDSL.PowerOperation","page":"Operations","title":"TensorDSL.PowerOperation","text":"PowerOperation(x::AbstractTensor{0}, y::AbstractTensor{0})\n\nSymbolises raising a scalar-shaped tensor x to a scalar-shaped power y.\n\n\n\n\n\n","category":"type"},{"location":"execute/#Compilation","page":"Execution and building","title":"Compilation","text":"","category":"section"},{"location":"execute/","page":"Execution and building","title":"Execution and building","text":"Oolong is compiled using FireDrake's infrastructure. The infrastructure is mostly in Python. The Pycall-module is used to call Python from Julia.","category":"page"},{"location":"execute/","page":"Execution and building","title":"Execution and building","text":"First Oolong-nodes can be translated to GEM, which is a part of TSFC. The function togem(node::Node) translates a given Oolong-node to GEM. The GEM is then futher compiled to Impero and from there to Loopy. Loopy is then compiled to C-code and executed using PyOp2.","category":"page"},{"location":"execute/","page":"Execution and building","title":"Execution and building","text":"In most cases the user does not need to do this directly. They can create a PyOp2 Kernel and execute it with the function execute(knl::Kernel, variables::Dict{String, T}) where T. If they want, they can also execute the node directly with the execute(knl::Kernel, variables::Dict{String, T}) where T-function.","category":"page"},{"location":"execute/","page":"Execution and building","title":"Execution and building","text":"Modules = [TensorDSL]\nPages   = [\"GenerateCode.jl\", \"togem.jl\"]","category":"page"},{"location":"execute/#TensorDSL.Kernel","page":"Execution and building","title":"TensorDSL.Kernel","text":"Kernel(node::Node)\n\nCreates a PyOp2 kernel from a given node. This can be executed repeatedly.\n\n\n\n\n\n","category":"type"},{"location":"execute/#TensorDSL.execute-Tuple{Union{Kernel, Node},Vararg{Pair,N} where N}","page":"Execution and building","title":"TensorDSL.execute","text":"execute(expr::Union{Node, Kernel}, variables::Vararg{Pair})\n\nExecute the Kernel knl or Node with the variable-assignments in variables.\n\nExample\n\njulia> A = VariableTensor(\"A\", RnSpace(3))\njulia> execute(A[1], \"A\"=>[1.0, 2.0, 3.0])\n1-element Array{Float64,1}:\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"execute/#TensorDSL.execute-Union{Tuple{T}, Tuple{Kernel,Dict{String,T}}} where T","page":"Execution and building","title":"TensorDSL.execute","text":"execute(expr::Union{Kernel, Node}, variables::Dict{String, T}) where T\n\nExecute the Kernel knl with the variable-assignments in variables.\n\nExample\n\njulia> A = VariableTensor(\"A\", RnSpace(3))\njulia> knl = Kernel(A[1])\njulia> execute(knl, Dict(\"A\"=>[1.0, 2.0, 3.0]))\n1-element Array{Float64,1}:\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"execute/#TensorDSL.togem-Tuple{Node}","page":"Execution and building","title":"TensorDSL.togem","text":"togem(node::Node)\n\nTranslates node into GEM.\n\n\n\n\n\n","category":"method"}]
}
